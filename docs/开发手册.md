# DZC-8M Plus 开发手册

## 前言

本开发手册用于提供以下内容供开发使用：

- 指令集
- 汇编语言写法
- 编译器/模拟器说明

遗憾的是，由于物理机ROM过小(仅16字节)，因此需尽可能优化程序的大小。  
并且尚未提供C语言支持。

## 汇编语言写法

本指令集所使用的汇编语言与大多数汇编语言类似，但不包含段定义等高级功能，也**不支持内存操作**。

### 注释

支持 C 语言风格注释：

```c
// 单行注释
/*
多行注释
*/
```

同时也支持脚本语言中常用的注释方式：

```python
# 单行注释
```

### 指令

指令行由**指令名**和**参数**构成，例如：

```c
ADD R2, R0, R1
```

参数之间可以使用空格或逗号进行分隔。

参数类型需遵循**指令集定义**，分为两种：

- 寄存器
- 常量

对于大多数指令，常量的取值范围为 `[0, 7]`。

### 标签

标签用于表示某个地址的占位符，单独占一行，后跟冒号，例如：

```c
flag:
```

标签可以作为常量出现在指令行中。  
标签名需符合以下规则：

- 只能包含**字母**、**数字**和**下划线**；
- 允许以数字开头，此时编译器会给出警告，但不影响编译；
- 仅包含数字的标签虽合法，但在编译时若出现相同数字，并不会被正确替换。

示例（无限循环）：

```c
loop:
    MOVN PC, loop, 1
```

如前所述，大多数指令的常量范围是 `[0, 7]`，在使用跳转指令时需注意常量范围限制。  
若 `MOVZ`/`MOVN` 的立即数范围不够，可使用 `MOVLZ`/`MOVLN`，它们支持 `[0, 255]` 范围内的赋值整数。

## 指令集

### 简介

本指令集在设计上接近CISC架构，但指令长度不随操作数类型或数值变化而改变，操作码位置也保持固定。这一特性有利于以较少的逻辑门资源实现指令译码器。

每条指令由**指令头**和**操作数**两部分组成。指令头固定占用前5字节。操作数可以是寄存器或立即数，其中寄存器通过其编号进行索引。

### 寄存器定义

| 编号 | 名称 | 用途 | 说明 |
| :-- | :-- | :-- | :-- |
| 0 (`0b000`) | PC | 程序计数器 | 指向下一条待执行指令的地址。写入该寄存器可实现程序跳转。详见「**特殊说明**」 |
| 1 (`0b001`) | AF | ALU标志寄存器 | 保存上一次ALU运算产生的状态标志。详见「**特殊说明**」 |
| 2 (`0b010`) | SP | 通用寄存器 | 本版本中无特殊约束，可用作通用寄存器，原设计意图为栈指针 |
| 3 (`0b011`) | IO | 输入输出寄存器 | 用于与外部设备进行数据交换，通信协议详见 **IO协议设计** |
| 4 (`0b100`) | R0 | 通用寄存器 | |
| 5 (`0b101`) | R1 | 通用寄存器 | |
| 6 (`0b110`) | R2 | 通用寄存器 | |
| 7 (`0b111`) | R3 | 通用寄存器 | |

所有寄存器的字长均为8位。

---

#### 特殊说明

**PC（程序计数器）**  
在执行指令前，PC 决定下一条指令的地址。若当前指令未显式修改 PC，则执行完成后 PC 会自动指向下一条指令。

**AF（ALU 标志寄存器）**  
存储上一次 ALU 运算结果的标志位，格式如下：

```text
[X][X][X][X][X][O][C][Z]
```

- **X**：保留位（无效）
- **O**：溢出标志（有符号数运算溢出时为 1，否则为 0）
- **C**：进位/借位标志（无符号数运算溢出时为 1，否则为 0）
- **Z**：零标志（运算结果为 0 时为 1，否则为 0）

AF 仅在执行加/减法指令时更新，其余指令不会影响其内容。该寄存器可写：若某次加/减法运算的结果被存入 AF，则 AF 中保存的是运算结果本身，而非标志位（结果优先级高于标志位）。

**SP（栈指针）**  
初始设计为通用指针寄存器，本版本中可作为普通寄存器使用。

**IO（输入输出寄存器）**  
用于与外部设备交互数据。在通信过程中，其值可能被自动修改，以反映输入操作的结果（如 `stdio::input`）。

### 操作数编码

**寄存器**直接存储其编号，占用3位。

**常量**则转换为二进制形式进行编码。大多数指令支持3位常量，取值范围为 `[0, 7]`；部分为长整数运算设计的指令支持8位全长常量，取值范围为 `[0, 255]`。

**值（Value）** 是一个统一的操作数表示形式，可代表寄存器或常量，占用4位。编码格式如下：

```text
[标志位: 1][数据: 3]
```

- **标志位**为 `0` 时，该值表示一个**寄存器**，数据字段为寄存器编号；
- **标志位**为 `1` 时，该值表示一个**常量**，数据字段为常量值。

### 指令集一览

#### 符号说明

| 符号 | 占用位数 | 含义 |
| :-- | :-- | :-- |
| `x` | 1 | 空位（取值不影响指令功能） |
| `R` | 3 | 寄存器编号，取值范围 `[0, 7]` |
| `C` | 3 | 3位常量，取值范围 `[0, 7]` |
| `C(n)` | `n` | `n`位常量，取值范围 `[0, 2ⁿ-1]` |
| `V` | 4 | 值类型操作数，编码方式见「**操作数编码**」 |

参数标识 `[名称]` 用于在汇编语法中引用该操作数。

#### 指令表

| 指令名 | 位布局 | 汇编写法 | 功能 | 详细说明 |
| :-- | :-- | :-- | :-- | :-- |
| PAUSE | `0000xxxx` | `PAUSE` | 暂停 | 暂停执行指令，直到用户手动恢复。某些 I/O 设备也可自动恢复执行。 |
| NOP | `0001xxxx` | `NOP` | 空操作 | 不执行任何操作。 |
| MOVZ | `00100R[Rd] V[Vs]V[Vc]` | `MOVZ Rd, Vs, Vc` | 条件赋值（零） | 若 `Vc == 0`，将 `Vs` 的值赋给 `Rd`。 |
| MOVLZ | `00101R[Rd] C(8)[Cs] V[Vc]xxxx` | `MOVLZ Rd, Cs, Vc` | 长常量条件赋值（零） | 若 `Vc == 0`，将 8 位常量 `Cs` 赋给 `Rd`。 |
| MOVN | `00110R[Rd] V[Vs]V[Vc]` | `MOVN Rd, Vs, Vc` | 条件赋值（非零） | 若 `Vc != 0`，将 `Vs` 的值赋给 `Rd`。 |
| MOVLN | `00111R[Rd] C(8)[Cs] V[Vc]xxxx` | `MOVLN Rd, Cs, Vc` | 长常量条件赋值（非零） | 若 `Vc != 0`，将 8 位常量 `Cs` 赋给 `Rd`。 |
| ADD | `0100xR[Rd] V[Va]V[Vb]` | `ADD Rd, Va, Vb` | 加法 | 计算 `Va + Vb`，结果存入 `Rd`，并更新标志位。 |
| SUB | `0101xR[Rd] V[Va]V[Vb]` | `SUB Rd, Va, Vb` | 减法 | 计算 `Va - Vb`，结果存入 `Rd`，并更新标志位。 |
| ADDC | `0110xR[Rd] V[Va]V[Vb]` | `ADDC Rd, Va, Vb` | 带进位加法 | 计算 `Va + Vb + AF:C`，结果存入 `Rd`，并更新标志位。 |
| SUBB | `0111xR[Rd] V[Va]V[Vb]` | `SUBB Rd, Va, Vb` | 带借位减法 | 计算 `Va - Vb - AF:C`，结果存入 `Rd`，并更新标志位。 |
| INC | `10000R[Rd]` | `INC Rd` | 自增 | 寄存器 `Rd` 的值加 1（`Rd++`），并更新标志位。 |
| DEC | `10001R[Rd]` | `DEC Rd` | 自减 | 寄存器 `Rd` 的值减 1（`Rd--`），并更新标志位。 |
| CMP | `1001xxxx V[Va]V[Vb]xxxx` | `CMP Va, Vb` | 比较 | 计算 `Va - Vb`，仅更新标志位，不存储结果。 |
| NOT | `1010xR[Rd] V[Vs]xxxx` | `NOT Rd, Vs` | 按位取反 | 计算 `~Vs`，结果存入 `Rd`。 |
| AND | `1011xR[Rd] V[Va]V[Vb]` | `AND Rd, Va, Vb` | 按位与 | 计算 `Va & Vb`，结果存入 `Rd`。 |
| OR | `1100xR[Rd] V[Va]V[Vb]` | `OR Rd, Va, Vb` | 按位或 | 计算 `Va \| Vb`，结果存入 `Rd`。 |
| XOR | `1101xR[Rd] V[Va]V[Vb]` | `XOR Rd, Va, Vb` | 按位异或 | 计算 `Va ^ Vb`，结果存入 `Rd`。 |
| SHL | `1110xR[Rd] V[Va]V[Vc]` | `SHL Rd, Va, Vc` | 左移 | 将 `Va` 左移 `Vc` 位，结果存入 `Rd`。 |
| SHR | `1111xR[Rd] V[Va]V[Vc]` | `SHR Rd, Va, Vc` | 右移 | 将 `Va` 右移 `Vc` 位，结果存入 `Rd`。 |

## 开发技巧

受指令编码长度的限制，指令集需在精简与完备之间取得平衡。本节介绍的**开发技巧**旨在帮助开发者充分利用指令特性，编写高效的程序。

### 跳转

如前所述，**通过修改 PC 寄存器即可实现程序跳转**。下面是一个无限循环的示例：

```c
loop:
    MOVN PC, loop, 1
```

汇编时，`loop` 标签会被自动替换为对应的地址。

### 分支实现

条件赋值指令的设计初衷，正是为了简洁地实现分支结构。

一个典型的分支示例如下：

```c
MOVZ R0, 1, 0      // 设置待测试的值 R0 = 1
MOVZ PC, r0_is_zero, R0  // 若 R0 == 0 则跳转

// r0_is_not_zero: (R0 != 0 时的分支)
    MOVZ R1, 2, 0
    MOVLZ PC, end, 0

r0_is_zero:
    // R0 == 0 时的分支
    MOVZ R1, 6, 0

end:
```

该程序等价于以下 C 语言逻辑：

```c
R0 = 1;
if (R0 == 0) {
    R1 = 6;
} else {
    R1 = 2;
}
```

将分支内的指令替换为更复杂的代码序列，即可实现任意复杂度的条件分支。

上述示例可以进一步优化为更简洁的形式：

```c
MOVZ R0, 1, 0      // R0 = 1
MOVN R1, 2, R0     // 若 R0 != 0，则 R1 = 2
MOVZ R1, 6, R0     // 若 R0 == 0，则 R1 = 6
```

### 数学关系判断

ALU 在执行加减运算时会更新标志位，我们可以利用这些标志位高效地判断数值关系。

#### 相等/不等判断

**标准减法判断：**

```c
SUB R2, R0, R1     // R2 = R0 - R1
```

- `R0 == R1` 时，`R2 = 0`
- `R0 != R1` 时，`R2 ≠ 0`

**利用零标志位：**

```c
CMP R0, R1         // 比较 R0 和 R1
AND R2, AF, 0b001  // 提取 AF:Z 位
```

- `R0 == R1` 时，`R2 = 1`
- `R0 != R1` 时，`R2 = 0`

**异或判断（推荐，稳定性最佳）：**

```c
XOR R2, R0, R1     // R2 = R0 ^ R1
```

利用异或运算性质：

- `R0 == R1` 时，`R2 = 0`
- `R0 != R1` 时，`R2 ≠ 0`

#### 无符号数大小判断

进位标志 `AF:C` 反映了无符号数运算中的借位情况。

**小于判断（`R0 < R1`）：**

```c
CMP R0, R1
AND R2, AF, 0b010  // 提取 AF:C 位
```

- 若 `R0 < R1`，则 `R2 = 2 (0b10)`
- 若 `R0 ≥ R1`，则 `R2 = 0`

**小于等于判断（`R0 ≤ R1`）：**

```c
CMP R0, R1
AND R2, AF, 0b011  // 提取 AF:C 和 AF:Z
```

- 若 `R0 ≤ R1`，则 `R2 ≠ 0`（可能为 0b01 或 0b10）
- 若 `R0 > R1`，则 `R2 = 0`

大于/大于等于的判断可通过交换操作数实现。

#### 有符号数大小判断

溢出标志 `AF:O` 反映了有符号数运算中的溢出情况。

**小于判断（`R0 < R1`）：**

```c
CMP R0, R1
AND R2, AF, 0b100  // 提取 AF:O 位
```

- 若 `R0 < R1`，则 `R2 = 4 (0b100)`
- 若 `R0 ≥ R1`，则 `R2 = 0`

### 应用示例：移位乘法器

以下实现了一个基于移位相加的乘法器：

```c
/*
移位乘法器
R0: 被乘数
R1: 乘数
R2: 乘积（结果）
R3: 临时寄存器
*/

_start:
    MOVZ R0, 6, 0   // 初始化被乘数
    MOVZ R1, 7, 0   // 初始化乘数

loop:
    AND R3, R1, 1   // 取乘数的最低位
    MOVLZ PC, skip_add, R3  // 若最低位为 0，跳过加法
    ADD R2, R2, R0  // 将被乘数累加到结果

skip_add:
    SHR R1, R1, 1   // 乘数右移一位
    SHL R0, R0, 1   // 被乘数左移一位
    MOVN PC, loop, R1  // 若乘数不为 0，继续循环
```
