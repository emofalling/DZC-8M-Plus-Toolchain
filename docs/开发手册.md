# DZC-8M Plus 开发手册

## 前言

本开发手册用于提供以下内容供开发使用：

- 指令集
- 汇编语言写法
- 编译器/模拟器说明

遗憾的是，由于物理机ROM过小(仅16字节)，因此需尽可能优化程序的大小。  
并且尚未提供C语言支持。

## 汇编语言写法

本指令集所使用的汇编语言与大多数汇编语言类似，但不包含段定义等高级功能，也**不支持内存操作**。

### 注释

支持 C 语言风格注释：

```c
// 单行注释
/*
多行注释
*/
```

同时也支持脚本语言中常用的注释方式：

```python
# 单行注释
```

### 指令

指令行由**指令名**和**参数**构成，例如：

```c
ADD R2, R0, R1
```

参数之间可以使用空格或逗号进行分隔。

参数类型需遵循**指令集定义**，分为两种：

- 寄存器
- 常量

对于大多数指令，常量的取值范围为 `[0, 7]`。

### 标签

标签用于表示某个地址的占位符，单独占一行，后跟冒号，例如：

```c
flag:
```

标签可以作为常量出现在指令行中。  
标签名需符合以下规则：

- 只能包含**字母**、**数字**和**下划线**；
- 允许以数字开头，此时编译器会给出警告，但不影响编译；
- 仅包含数字的标签虽合法，但在编译时若出现相同数字，并不会被正确替换。

示例（无限循环）：

```c
loop:
    MOVN PC, loop, 1
```

如前所述，大多数指令的常量范围是 `[0, 7]`，在使用跳转指令时需注意常量范围限制。  
若 `MOVZ`/`MOVN` 的立即数范围不够，可使用 `MOVLZ`/`MOVLN`，它们支持 `[0, 255]` 范围内的赋值整数。

### 起始点

它没有起始点。从地址`0x00`处开始执行指令。

## 指令集

### 简介

本指令集在设计上接近CISC架构，但指令长度不随操作数类型或数值变化而改变，操作码位置也保持固定。这一特性有利于以较少的逻辑门资源实现指令译码器。

每条指令由**指令头**和**操作数**两部分组成。指令头固定占用前5字节。操作数可以是寄存器或立即数，其中寄存器通过其编号进行索引。

### 寄存器定义

| 编号 | 名称 | 用途 | 说明 |
| :-- | :-- | :-- | :-- |
| 0 (`0b000`) | PC | 程序计数器 | 指向下一条待执行指令的地址。写入该寄存器可实现程序跳转。详见「**特殊说明**」 |
| 1 (`0b001`) | AF | ALU标志寄存器 | 保存上一次ALU运算产生的状态标志。详见「**特殊说明**」 |
| 2 (`0b010`) | SP | 通用寄存器 | 本版本中无特殊约束，可用作通用寄存器，原设计意图为栈指针 |
| 3 (`0b011`) | IO | 输入输出寄存器 | 用于与外部设备进行数据交换，通信协议详见 **IO协议设计** |
| 4 (`0b100`) | R0 | 通用寄存器 | |
| 5 (`0b101`) | R1 | 通用寄存器 | |
| 6 (`0b110`) | R2 | 通用寄存器 | |
| 7 (`0b111`) | R3 | 通用寄存器 | |

所有寄存器的字长均为8位。

---

#### 特殊说明

**PC（程序计数器）**  
在执行指令前，PC 决定下一条指令的地址。若当前指令未显式修改 PC，则执行完成后 PC 会自动指向下一条指令。

**AF（ALU 标志寄存器）**  
存储上一次 ALU 运算结果的标志位，格式如下：

```text
[X][X][X][X][X][O][C][Z]
```

- **X**：保留位（无效）
- **O**：溢出标志（有符号数运算溢出时为 1，否则为 0）
- **C**：进位/借位标志（无符号数运算溢出时为 1，否则为 0）
- **Z**：零标志（运算结果为 0 时为 1，否则为 0）

AF 仅在执行加/减法指令时更新，其余指令不会影响其内容。该寄存器可写：若某次加/减法运算的结果被存入 AF，则 AF 中保存的是运算结果本身，而非标志位（结果优先级高于标志位）。

**SP（栈指针）**  
初始设计为通用指针寄存器，本版本中可作为普通寄存器使用。

**IO（输入输出寄存器）**  
用于与外部设备交互数据。在通信过程中，其值可能被自动修改，以反映输入操作的结果（如 `stdio::input`）。

### 操作数编码

**寄存器**直接存储其编号，占用3位。

**常量**则转换为二进制形式进行编码。大多数指令支持3位常量，取值范围为 `[0, 7]`；部分为长整数运算设计的指令支持8位全长常量，取值范围为 `[0, 255]`。

**值（Value）** 是一个统一的操作数表示形式，可代表寄存器或常量，占用4位。编码格式如下：

```text
[标志位: 1][数据: 3]
```

- **标志位**为 `0` 时，该值表示一个**寄存器**，数据字段为寄存器编号；
- **标志位**为 `1` 时，该值表示一个**常量**，数据字段为常量值。

### 指令集一览

#### 符号说明

| 符号 | 占用位数 | 含义 |
| :-- | :-- | :-- |
| `x` | 1 | 空位（取值不影响指令功能） |
| `R` | 3 | 寄存器编号，取值范围 `[0, 7]` |
| `C` | 3 | 3位常量，取值范围 `[0, 7]` |
| `C(n)` | `n` | `n`位常量，取值范围 `[0, 2ⁿ-1]` |
| `V` | 4 | 值类型操作数，编码方式见「**操作数编码**」 |

参数标识 `[名称]` 用于在汇编语法中引用该操作数。

#### 指令表

| 指令名 | 位布局 | 汇编写法 | 功能 | 详细说明 |
| :-- | :-- | :-- | :-- | :-- |
| PAUSE | `0000xxxx` | `PAUSE` | 暂停 | 暂停执行指令，直到用户手动恢复。某些 I/O 设备也可自动恢复执行。 |
| NOP | `0001xxxx` | `NOP` | 空操作 | 不执行任何操作。 |
| MOVZ | `00100R[Rd] V[Vs]V[Vc]` | `MOVZ Rd, Vs, Vc` | 条件赋值（零） | 若 `Vc == 0`，将 `Vs` 的值赋给 `Rd`。 |
| MOVLZ | `00101R[Rd] C(8)[Cs] V[Vc]xxxx` | `MOVLZ Rd, Cs, Vc` | 长常量条件赋值（零） | 若 `Vc == 0`，将 8 位常量 `Cs` 赋给 `Rd`。 |
| MOVN | `00110R[Rd] V[Vs]V[Vc]` | `MOVN Rd, Vs, Vc` | 条件赋值（非零） | 若 `Vc != 0`，将 `Vs` 的值赋给 `Rd`。 |
| MOVLN | `00111R[Rd] C(8)[Cs] V[Vc]xxxx` | `MOVLN Rd, Cs, Vc` | 长常量条件赋值（非零） | 若 `Vc != 0`，将 8 位常量 `Cs` 赋给 `Rd`。 |
| ADD | `0100xR[Rd] V[Va]V[Vb]` | `ADD Rd, Va, Vb` | 加法 | 计算 `Va + Vb`，结果存入 `Rd`，并更新标志位。 |
| SUB | `0101xR[Rd] V[Va]V[Vb]` | `SUB Rd, Va, Vb` | 减法 | 计算 `Va - Vb`，结果存入 `Rd`，并更新标志位。 |
| ADDC | `0110xR[Rd] V[Va]V[Vb]` | `ADDC Rd, Va, Vb` | 带进位加法 | 计算 `Va + Vb + AF:C`，结果存入 `Rd`，并更新标志位。 |
| SUBB | `0111xR[Rd] V[Va]V[Vb]` | `SUBB Rd, Va, Vb` | 带借位减法 | 计算 `Va - Vb - AF:C`，结果存入 `Rd`，并更新标志位。 |
| INC | `10000R[Rd]` | `INC Rd` | 自增 | 寄存器 `Rd` 的值加 1（`Rd++`），并更新标志位。 |
| DEC | `10001R[Rd]` | `DEC Rd` | 自减 | 寄存器 `Rd` 的值减 1（`Rd--`），并更新标志位。 |
| CMP | `1001xxxx V[Va]V[Vb]xxxx` | `CMP Va, Vb` | 比较 | 计算 `Va - Vb`，仅更新标志位，不存储结果。 |
| NOT | `1010xR[Rd] V[Vs]xxxx` | `NOT Rd, Vs` | 按位取反 | 计算 `~Vs`，结果存入 `Rd`。 |
| AND | `1011xR[Rd] V[Va]V[Vb]` | `AND Rd, Va, Vb` | 按位与 | 计算 `Va & Vb`，结果存入 `Rd`。 |
| OR | `1100xR[Rd] V[Va]V[Vb]` | `OR Rd, Va, Vb` | 按位或 | 计算 `Va \| Vb`，结果存入 `Rd`。 |
| XOR | `1101xR[Rd] V[Va]V[Vb]` | `XOR Rd, Va, Vb` | 按位异或 | 计算 `Va ^ Vb`，结果存入 `Rd`。 |
| SHL | `1110xR[Rd] V[Va]V[Vc]` | `SHL Rd, Va, Vc` | 左移 | 将 `Va` 左移 `Vc` 位，结果存入 `Rd`。 |
| SHR | `1111xR[Rd] V[Va]V[Vc]` | `SHR Rd, Va, Vc` | 右移 | 将 `Va` 右移 `Vc` 位，结果存入 `Rd`。 |

## 开发技巧

受指令编码长度的限制，指令集需在精简与完备之间取得平衡。本节介绍的**开发技巧**旨在帮助开发者充分利用指令特性，编写高效的程序。

### 跳转

如前所述，**通过修改 PC 寄存器即可实现程序跳转**。下面是一个无限循环的示例：

```c
loop:
    MOVN PC, loop, 1
```

汇编时，`loop` 标签会被自动替换为对应的地址。

### 分支实现

条件赋值指令的设计初衷，正是为了简洁地实现分支结构。

一个典型的分支示例如下：

```c
MOVZ R0, 1, 0      // 设置待测试的值 R0 = 1
MOVZ PC, r0_is_zero, R0  // 若 R0 == 0 则跳转

// r0_is_not_zero: (R0 != 0 时的分支)
    MOVZ R1, 2, 0
    MOVLZ PC, end, 0

r0_is_zero:
    // R0 == 0 时的分支
    MOVZ R1, 6, 0

end:
```

该程序等价于以下 C 语言逻辑：

```c
R0 = 1;
if (R0 == 0) {
    R1 = 6;
} else {
    R1 = 2;
}
```

将分支内的指令替换为更复杂的代码序列，即可实现任意复杂度的条件分支。

可以添加更多的跳转标签来实现更复杂的标签结构：

```c
MOVZ R0, 1, 0      // 设置待测试的值 R0 = 1
MOVZ PC, r0_is_0, R0  // 若 R0 == 0 则跳转
SUB R1, R0, 3
MOVLZ PC, r0_is_3, R1  // 若 R0 = 3，则跳转
AND R1, R0, 1
MOVLN PC, r0_is_odd, R1  // 若 R0 为奇数，则跳转

// else:
    MOVZ R2, 4, 0
    MOVLZ PC, end, 0

r0_is_0:
    MOVZ R2, 1, 0
    MOVLZ PC, end, 0

r0_is_3:
    MOVZ R2, 2, 0
    MOVLN PC, end, 0

r0_is_odd:
    MOVZ R2, 3, 0
end:
```

等价于以下 C 语言逻辑：

```c
R0 = 1;
if (R0 == 0) {
    R2 = 1;
} else if (R0 == 3) {
    R2 = 2;
} else if (R0 & 1 != 0) {
    R2 = 3;
} else {
    R2 = 4;
}
```

如果只是条件赋值，可以进一步优化为更简洁的形式，例如：

```c
MOVZ R0, 1, 0      // R0 = 1
MOVN R1, 2, R0     // 若 R0 != 0，则 R1 = 2
MOVZ R1, 6, R0     // 若 R0 == 0，则 R1 = 6
```

### 循环

循环结构可通过跳转指令实现。以下从最简单的无限循环开始，逐步介绍各种循环模式的实现方法。

#### 无限循环

最简单的循环形式是无限循环，通过无条件跳转实现：

```c
loop:
    // 循环体代码
    MOVN PC, loop, 1   // 无条件跳转回 loop 标签
// 后续代码（理论上永远不会被执行）
```

等效的 C 语言逻辑：

```c
while (1) {
    // 循环体
}
// 后续代码（永远不会执行）
```

#### 计数循环

对于已知循环次数的场景，可以使用一个寄存器作为计数器，在每次循环结束时递减并判断：

```c
MOVZ R0, 10, 0      // 初始化计数器 R0 = 10（循环次数）

count_loop:
    // 循环体代码
    DEC R0                    // 计数器减 1
    MOVN PC, count_loop, R0   // 若 R0 != 0，继续循环
// 循环结束，执行后续代码
```

等效的 C 语言逻辑：

```c
for (R0 = 10; R0 > 0; --R0) {
    // 循环体
}
// 后续代码
```

#### 条件循环

当循环终止条件较为复杂时，可以在循环体内计算条件，并通过条件跳转指令控制循环：

```c
MOVZ R0, 4, 0        // 初始化 R0 = 4

conditional_loop:
    // 循环体代码
    DEC R0                    // R0 自减

    // 判断是否继续循环：当 R0 == 3 时继续
    SUB R1, R0, 3             // R1 = R0 - 3
    MOVZ PC, conditional_loop, R1  // 若 R1 == 0（即 R0 == 3），继续循环
// 循环结束，执行后续代码
```

等效的 C 语言逻辑：

```c
R0 = 4;
do {
    // 循环体
    R0--;
} while (R0 == 3);  // 当 R0 等于 3 时继续循环
```

#### 循环嵌套

循环可以相互嵌套，只需注意不同层次的循环使用不同的计数器寄存器即可：

```c
MOVZ R0, 5, 0        // 外层循环计数器
outer_loop:
    MOVZ R1, 3, 0    // 内层循环计数器
    inner_loop:
        // 内层循环体
        DEC R1
        MOVN PC, inner_loop, R1  // 内层循环判断
    // 外层循环体（可包含其他操作）
    DEC R0
    MOVN PC, outer_loop, R0      // 外层循环判断
// 所有循环结束
```

**编写建议：**

- 计数循环中，建议将计数器初始值设为循环次数，递减至零时退出
- 注意保护循环计数器不被循环体中的其他操作意外修改
- 嵌套循环时，确保不同层次的计数器使用不同的寄存器

### 大小关系判断

ALU 在执行加减运算时会更新标志位，我们可以利用这些标志位高效地判断数值关系。

#### 相等/不等判断

**标准减法判断：**

```c
SUB R2, R0, R1     // R2 = R0 - R1
```

- `R0 == R1` 时，`R2 = 0`
- `R0 != R1` 时，`R2 ≠ 0`

**利用零标志位：**

```c
CMP R0, R1         // 比较 R0 和 R1
AND R2, AF, 0b001  // 提取 AF:Z 位
```

- `R0 == R1` 时，`R2 = 1`
- `R0 != R1` 时，`R2 = 0`

**异或判断（推荐，稳定性最佳）：**

```c
XOR R2, R0, R1     // R2 = R0 ^ R1
```

利用异或运算性质：

- `R0 == R1` 时，`R2 = 0`
- `R0 != R1` 时，`R2 ≠ 0`

#### 无符号数大小判断

进位标志 `AF:C` 反映了无符号数运算中的借位情况。

**小于（`R0 < R1`）与大于等于（`R0 ≥ R1`）：**

```c
CMP R0, R1
AND R2, AF, 0b010  // 提取 AF:C 位
```

- 若 `R0 < R1`，则 `R2 = 2 (0b10)`
- 若 `R0 ≥ R1`，则 `R2 = 0`

**小于等于判断（`R0 ≤ R1`）与大于（`R0 > R1`）：**

```c
CMP R0, R1
AND R2, AF, 0b011  // 提取 AF:C 和 AF:Z
```

- 若 `R0 ≤ R1`，则 `R2 ≠ 0`（可能为 0b01 或 0b10）
- 若 `R0 > R1`，则 `R2 = 0`

大于/大于等于的判断可通过交换操作数实现。

#### 有符号数大小判断

有符号数的比较相对复杂，需要综合运用溢出标志 `AF:O` 和运算结果的符号位（即结果的最高位）。由于指令集未针对有符号数提供专门的优化指令，建议在复杂计算中尽量避免使用有符号数。

**小于判断（`R0 < R1`）与大于等于（`R0 ≥ R1`）**

有符号数比较的核心是判断**溢出标志 O 与结果符号位 N 是否相等**。若 `O == N`，则表示 `R0 ≥ R1`；若 `O ≠ N`，则表示 `R0 < R1`。

其原理在于：

- 若运算未发生溢出（`O == 0`），差的符号位 N 即为实际比较结果；
- 若运算发生溢出（`O == 1`），差的符号位与实际结果相反。

实现代码如下：

```c
SUB R2, R0, R1      // R2 = R0 - R1，此时 AF 中保存溢出标志 O
SHR R2, R2, 5       // 将结果右移 5 位，使符号位 N 移至第 2 位（对应 AF:O 的位置）
XOR R2, AF, R2      // 比较 O 与 N：若 O == N 则 R2 第 2 位为 0，否则为 1
AND R2, R2, 0b100   // 提取第 2 位作为结果
```

- 若 `R0 < R1`，则 `R2 = 4 (0b100)`
- 若 `R0 ≥ R1`，则 `R2 = 0`

**小于等于判断（`R0 ≤ R1`）与大于（`R0 > R1`）**

此判断在小于判断的基础上增加了对相等情况的处理，即判断条件为 `(O != N) || Z`：

- 当 `Z == 1` 时，两数相等，条件成立；
- 当 `Z == 0` 时，结果不为零，此时退化为小于判断的逻辑。

实现代码如下：

```c
SUB R2, R0, R1      // R2 = R0 - R1，AF 中包含 O 和 Z
SHR R2, R2, 5       // 将结果右移 5 位，使符号位 N 移至第 2 位（对应 AF:O 的位置）
AND R2, R2, 0b100   // 仅保留符号位 N（位于第 2 位）
XOR R2, AF, R2      // 比较 O 与 N：若 O == N 则 R2 第 2 位为 0，否则为 1；同时 AF 中的 Z 位被保留
AND R2, R2, 0b101   // 提取第 0 位（Z）和第 2 位（O != N 的结果）
```

- 若 `R0 ≤ R1`，则 `R2 ≠ 0`（可能为 0b001 或 0b100）
- 若 `R0 > R1`，则 `R2 = 0`

### 优化

由于实机的 ROM 空间非常有限，优化工作不仅需要在单个功能模块内精打细算，更需要跨模块、跨功能地进行全局性代码体积与执行效率的权衡。

该架构处理器为在有限的编码空间中密集堆叠功能而设计，因此不具备缓存、流水线等高级结构。所有指令（包括跳转指令）的执行时间均等。基于这一特性，优化工作的重心主要放在**代码体积压缩**和**算法理论效率提升**两个方面。

#### 跳转指令的选择

如前所述，跳转的本质是给 PC 寄存器赋值。根据跳转目标的范围，条件赋值指令分为两类：

- **短跳转指令**：`MOVZ`、`MOVN`。可赋值的范围仅为 `0~7`，占用 **2 字节**。
- **长跳转指令**：`MOVLZ`、`MOVLN`。可赋值全长常量（`0~255`），占用 **3 字节**。

合理选择跳转指令能够在保证功能的前提下有效减小代码体积、提升执行效率。显而易见，短跳转指令的体积小于长跳转指令。

若短跳转指令的赋值范围无法满足跳转需求，汇编器将报错提示。例如：

```c
PS D:\emofalling\DZC-8M Plus 工具链> ./cp.py example/prime.c
错误: 参数1常量值超出范围，目标值域为[0, 7]，实际11
    30 |     MOVZ PC, loop_mod, AF  // if R2 > R1 goto loop_mod

编译失败，存在错误。
```

除了指令本身的选择，**跳转条件的优化**同样值得关注。通过仔细观察程序逻辑或借助优化工具自动分析，有时可以选用更简洁的跳转条件，从而减少无效分支的产生。

更进一步，还可以利用 `ADD`/`SUB` 等算术指令实现**相对跳转**，这在某些场景下能带来更紧凑的代码：

```c
...
loop:               // 地址: 0x03
    ...
    SUB PC, PC, 5   // 地址: 0x08，相对跳转回 loop
```

需要注意的是，当前版本的编译器尚不支持通过标记直接实现此类高级相对跳转（该功能计划在未来添加）。

#### 分支合并

当多个条件分支中包含相同的代码段时，可以通过**重叠跳转**将它们合并为同一个代码块，从而消除冗余。

考虑以下代码：

```c
check:
    ...

is_prime:
    PAUSE
    INC R0
    MOVZ PC, check, 0

is_not_prime:
    INC R0
    MOVZ PC, check, 0
```

观察发现，`is_prime` 和 `is_not_prime` 分支的尾部代码完全相同。可以合并为：

```c
check:
    ...

is_prime:
    PAUSE          // 仅属于 is_prime 的独特处理
                    // 执行完后自然流入公共代码段

is_not_prime:
    INC R0
    MOVZ PC, check, 0
```

合并后，原本两处重复的 `INC R0` 和跳转指令被缩减为一处，有效减小了代码体积。

复杂的算法或业务逻辑中往往蕴含着大量此类优化机会。由于这些优化点形态各异，既需要开发者细致观察和推导，也可借助优化工具进行自动化分析识别。

#### 高级算术优化

位运算作为一种直接操作二进制位的基本运算，比常规算术运算具有更高的执行效率和更好的稳定性。合理运用位运算可以显著提升代码质量。

**乘除运算的优化**

对于乘以或除以 2 的幂次这类特殊运算，可以使用位移指令高效实现

- `SHL`（左移）：每左移一位相当于乘以 2
- `SHR`（右移）：每右移一位相当于除以 2

例如，将 R0 乘以 8 可以写为 `SHL R0, R0, 3`（左移 3 位），这比循环加法高效得多。

**加减运算的优化**

加法运算可通过 `ADD` 和 `INC` 两种指令实现。由于 `INC` 仅占用 **1 字节**，而 `ADD` 需要更多空间，因此在简单的累加场景中优先使用 `INC` 能够获得更紧凑的代码：

```c
INC R0      // 推荐：1 字节，R0 = R0 + 1
ADD R0, R0, 1  // 不推荐：体积较大，R0 = R0 + 1
```

减法运算同理，`DEC` 指令优于 `SUB` 指令。

**乘除法的实现策略**

该架构处理器未提供直接的乘法和除法指令，开发者需要自行实现这两种运算。通常有两种实现方式，需要在代码体积和执行效率之间做出权衡：

| 实现方式 | 代码体积 | 执行效率 | 适用场景 |
| :-- | :-- | :-- | :-- |
| **循环累加/递减法** | 小 | 低 | 对代码体积敏感，且乘除次数较少的场景 |
| **移位乘/除法** | 大 | 高 | 对执行效率要求高，且不介意代码体积增大的场景 |

**循环累加/递减法**通过不断加/减被乘/除数来实现，虽然代码紧凑但执行速度慢：

```c
// 循环加法实现乘法示例（R0 × R1 → R2）
MOVZ R2, 0, 0
mul_loop:
    ADD R2, R2, R0
    DEC R1
    MOVN PC, mul_loop, R1
```

**移位乘/除法**采用二进制移位累加算法，虽然代码量较大但执行效率高（具体实现可参考前文“移位乘法器”示例）。

**优化要点总结：**

- 优先选用短跳转指令（`MOVZ`/`MOVN`），仅在必要时使用长跳转
- 审视跳转条件，寻找更简洁的判断方式
- 考虑使用算术指令实现相对跳转（待编译器支持）
- 合并多个分支中的公共代码段
- 在复杂逻辑中保持对优化机会的敏感性
- 优先使用位运算替代常规乘除（针对 2 的幂次）
- 简单计数场景优先选用 `INC`/`DEC`
- 根据实际需求权衡两种乘除实现方式：
  - 对体积敏感时选用循环法
  - 对性能敏感时选用移位法

#### 优化示例：质数输出器

下面通过一个质数输出程序展示实际优化过程。该程序从 2 开始逐个检测并输出质数，每输出一个质数时暂停执行。


优化前：
```c
/*
从 2 开始输出所有质数
R0: 当前待检测的数（输出质数时暂停）
R1: 除数
R2: 缓存寄存器
*/

MOVZ R0, 2, 0 // R0 = 2

next:
    MOVZ R1, 2, 0 // R1 = 2
    check_loop:
        // R1 == R0, goto is_prime
        SUB R2, R0, R1 // R2 = R0 - R1
        MOVLZ PC, is_prime, R2
        // R2 = R0 % R1
        MOVZ R2, R0, 0 // R2 = R0
        // while(R2 >= R1) R2 -= R1
        mod_loop:
            SUB R2, R2, R1 // R2 -= R1
            CMP R2, R1
            AND AF, AF, 0b010 // 提取 AF:C 位。AF=0, 继续循环
            MOVLZ PC, mod_loop, AF
        // if(R2 == 0) goto is_not_prime
        MOVLZ PC, is_not_prime, R2
        INC R1 // R1++
        MOVZ PC, check_loop, 0 // goto check_loop

    is_prime:
        PAUSE
        INC R0 // R0++
        MOVZ PC, next, 0 // goto next

    is_not_prime:
        INC R0 // R0++
        MOVZ PC, next, 0 // goto next
```

简单优化后：

```c
/*
从 2 开始输出所有质数
R0: 当前待检测的数（输出质数时暂停）
R1: 除数
R2: 缓存寄存器
*/

MOVZ R0, 2, 0 // R0 = 2

next:
    MOVZ R1, 2, 0 // R1 = 2
    check_loop:
        // R1 == R0, goto is_prime
        XOR R2, R0, R1
        MOVLZ PC, is_prime, R2
        // R2 = R0 % R1
        MOVZ R2, R0, 0 // R2 = R0
        // while(R2 >= R1) R2 -= R1
        mod_loop:
            SUB R2, R2, R1 // R2 -= R1，同时产生相较于原本的R1和R2的符号位
            AND AF, AF, 0b011 // 提取 AF:C|Z 位。R2 > R1, AF=0.
            MOVLZ PC, mod_loop, AF
        // if(R2 == 0) goto is_not_prime
        MOVLZ PC, is_not_prime, R2
        INC R1 // R1++
        MOVZ PC, check_loop, 0 // goto check_loop

    is_prime:
        PAUSE
    is_not_prime:
        INC R0 // R0++
        MOVZ PC, next, 0 // goto next
```

主要优化点：
1. 用 `XOR` 替代 `SUB` 进行相等性判断（更稳定）
2. 合并取模循环的条件判断（减少指令数）
3. 合并 `is_prime` 和 `is_not_prime` 的公共代码段

更多的优化空间可以自行思考。

### 应用示例：移位乘法器

以下实现了一个基于移位相加的乘法器：

```c
/*
移位乘法器
R0: 被乘数
R1: 乘数
R2: 乘积（结果）
R3: 临时寄存器
*/

MOVZ R0, 6, 0   // 初始化被乘数
MOVZ R1, 7, 0   // 初始化乘数

loop:
    AND R3, R1, 1   // 取乘数的最低位
    MOVLZ PC, skip_add, R3  // 若最低位为 0，跳过加法
    ADD R2, R2, R0  // 将被乘数累加到结果

skip_add:
    SHR R1, R1, 1   // 乘数右移一位
    SHL R0, R0, 1   // 被乘数左移一位
    MOVN PC, loop, R1  // 若乘数不为 0，继续循环
```
